{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/LeetCode","result":{"pageContext":{"currentCategory":"LeetCode","categories":["All","Programmers","JSPAS","LeetCode"],"edges":[{"node":{"id":"fcb5de9d-3c1c-5784-af23-30cae150fc08","excerpt":"문제 설명 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". 입출력 예 Example 1: Input: strs = [“flower”,“flow”,“flight”]\nOutput: “fl” Example 2: Input: strs = [“dog”,“racecar”,“car”]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings. Constraints: 1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only Lower-Case English letters. 나의 풀이 다른 사람 풀이 알게 된 것 전달 받는 문자열 배열에서 …","fields":{"slug":"/problem-solving/20230210-1/"},"frontmatter":{"categories":"LeetCode","title":"Longest Common Prefix","date":"February 10, 2023"}},"next":{"fields":{"slug":"/problem-solving/20230209-2/"}},"previous":{"fields":{"slug":"/problem-solving/20230210-2/"}}},{"node":{"id":"fc3acb21-0156-57f6-8cba-004398ecf1a5","excerpt":"문제 설명 Given an integer x, return true if x is palindrome integer. An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not. 입출력 예 Example 1: Input: x = 121\nOutput: true\nExample 2: Input: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\nExample 3: Input: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palin…","fields":{"slug":"/problem-solving/20230209-2/"},"frontmatter":{"categories":"LeetCode","title":"Palindrome Number","date":"February 09, 2023"}},"next":{"fields":{"slug":"/problem-solving/20230209-1/"}},"previous":{"fields":{"slug":"/problem-solving/20230210-1/"}}},{"node":{"id":"38f6c47f-d93c-5721-980e-c2e6af4ffbf3","excerpt":"문제 설명 Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. 입출력 예 Example 1: Input: nums = [1,2,3,1]\nOutput: true\nExample 2: Input: nums = [1,2,3,4]\nOutput: false\nExample 3: Input: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true Constraints: 1 <= nums.length <= 105\n-109 <= nums[i] <= 109 나의 풀이 다른 사람의 풀이 1 다른 사람의 풀이 2 다른 사람의 풀이 3 알게 된 것 왠지 문제를 이중 for문을 통해 solving을 할 것같아 객체를 생성하여 진행해 보았다. 빈 객체에 전달받은 인자의 배열 값을 key로, valu…","fields":{"slug":"/problem-solving/20230209-1/"},"frontmatter":{"categories":"LeetCode","title":"Contains Duplicate","date":"February 09, 2023"}},"next":{"fields":{"slug":"/problem-solving/20230208-2/"}},"previous":{"fields":{"slug":"/problem-solving/20230209-2/"}}},{"node":{"id":"55cb149b-da0a-5fca-bc88-bb149b3fd8bf","excerpt":"문제 설명 You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 입출력 예 Example 1: Input: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that …","fields":{"slug":"/problem-solving/20230208-2/"},"frontmatter":{"categories":"LeetCode","title":"Best Time to Buy and Sell Stock","date":"February 08, 2023"}},"next":{"fields":{"slug":"/problem-solving/20230208-1/"}},"previous":{"fields":{"slug":"/problem-solving/20230209-1/"}}},{"node":{"id":"2470a9ab-9c6c-542c-be55-c4ae5b4066c8","excerpt":"문제 설명 Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. 입출력 예 ▣ 입력설명 nums: Number Array, target: Number ▣ 출력설명 Example 1: Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0] Example 2: Input: nums = [0]\nOutput: [0] Constraints: 1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1 나의 풀이 다른 사람의 풀이 알게 된 것 비교적 간단할 줄 알았지만 새로운 배열을 생성하지 말고 기존 배열을 통해 문제 풀이를 하란 요구 사항으…","fields":{"slug":"/problem-solving/20230208-1/"},"frontmatter":{"categories":"LeetCode","title":"Move Zeroes","date":"February 08, 2023"}},"next":{"fields":{"slug":"/problem-solving/20230207-2/"}},"previous":{"fields":{"slug":"/problem-solving/20230208-2/"}}},{"node":{"id":"02508a75-cd52-5606-94d5-9d1e8dc2fdc4","excerpt":"문제 설명 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order. 입출력 예 ▣ 입력설명 nums: Number Array, target: Number ▣ 출력설명 Example 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nOutput: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2:\nInput: nums = [3,2,4], target = 6\nOu…","fields":{"slug":"/problem-solving/20230207-2/"},"frontmatter":{"categories":"LeetCode","title":"Two Sum","date":"February 07, 2023"}},"next":{"fields":{"slug":"/problem-solving/20230207-1/"}},"previous":{"fields":{"slug":"/problem-solving/20230208-1/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}